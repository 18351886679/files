# 大端和小端
## 概念由来
&emsp;&emsp;现在先来理解这对概念，大端和小端这两个令人迷惑的术语究竟是如何产生的？《程序设计实践》第9章中提到，“大端”和“小端”可以追溯到1726年的Jonathan Swift的《格列佛游记》，其中一篇讲到有两个国家因为吃鸡蛋究竟是先打破较大的一端还是先打破较小的一端而争执不休，甚至爆发了战争。1981年10月，Danny Cohen的文章《论圣战以及对和平的祈祷》（On holy wars and a plea for peace）将这一对词语引入了计算机界。这么看来，所谓大端和小端，也就是big-endian和little-endian，其实是从描述鸡蛋的部位而引申到计算机地址的描述，也可以说，是从一个俚语衍化来的计算机术语。稍有些英语常识的人都会知道，如果单靠字面意思来理解俚语，那是很难猜到它的正确含义的。在计算机里，对于地址的描述，很少用“大”和“小”来形容；对应地，用的更多的是“高”和“低”；很不幸地，这对术语直接按字面翻译过来就成了“大端”和“小端”，让人产生迷惑也不是很奇怪的事了。

## 记忆方式
&emsp;&emsp;在裘宗燕翻译的《程序设计实践》里，这对术语并没有翻译为“大端”和小端，而是“高尾端”和“低尾端”，这就好理解了：如果把一个数看成一个字符串，比如11223344看成"11223344"，末尾是个'\0'，'11'到'44'个占用一个存储单元，那么它的尾端很显然是44，前面的高还是低就表示尾端放在高地址还是低地址，它在内存中的放法非常直观，如下图：
![](../img/大端和小端.png)

## 测试代码
&emsp;&emsp;这两种字节序没有标准可循，都有系统在使用。把某个给定系统所用的字节序称为主机字节序，可以用以下程序输出主机字节序。方法是在一个短整数变量中存放2字节的值0x0102，然后查看它的连续字节c[0]（对应上图地址A）和c[1]（对应上图地址A+1），以此确定字节序。

见`./big_endian_and_little_endian/main.c`s

## 扩展-内存单元8bit的由来
[wiki-Byte](https://en.wikipedia.org/wiki/Byte)
